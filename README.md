### 一. 蓝图与红图

1. 蓝图是 `app` 级别的分离，蓝图是通过 `add_url_rule` 方法添加 `url` 的，使用自定义的红图调用蓝图的 `add_url_rule` 实现接口级别的分离。并通过添加 `url` 前缀优化代码。

### 二. 支持多种登录

1. 为了方便多种验证，可创建一个 `client` 接口，提供各种登录注册，首先定义一个登录类型的枚举类，每次调用登录接口需传入这个枚举类型对应的值。
2. 登录验证器先创建一个 各种登录公有参数的基类，再每个具体类继承后，自行添加需要验证的参数，为了代码的可读性，需将传入的 枚举类型的值 转换为 枚举类型，然后将枚举类型放回给验证器，后续取出就是枚举类型。再创建一个 {枚举类型：对应登录的处理函数} 的字典，即可动态注册登录
3. 为了能抛出验证器的异常，需要基础 `wtfroms` 的 `Form` ，然后写一个 `validata_for_api `的方法，如果不通过验证，就抛出异常，而不是从 data.errors 中取。
4. 为了适应多种异常，我们需继承 `werkzeug.exceptions` 中的 `HTTPException` 然后编写一个自己的 `APIException` 类。 然后实现自己的 ` get_body` 和 `get_headers `这2个方法
5. 之后我们每个接口错误的异常都可以自己继承 APIException 然后定义自己的 http 状态码，错误消息和错误码，需要写一个错误码的文档记录。另外，成功信息的 json 返回也可利用这个 APIException 来快速返回。
6. 利用 `AOP` 思想，在全局出口拦截 `python 代`码级别的异常，使用 `flask` 提供的 `app.errorhandler` 函数，并对三种异常  `APIException` , `HTTPException` , 其他异常做处理，返回统一的 `JSON` 格式信息
7. `delete` 请求方式默认放回的状态码是 204 ，204 是不会又任何放回内容的，这与我们设计的统一 JSON 返回有冲突，所以建议改成 202 之类的，然后将我们设计的 JSON 中错误码的字段修改为 1 即可放回统一的 JSON 格式

### 三. Token

1. 因为 `api` 不一定是浏览器调用，可能没有 `cookies` ，所以使用 token 令牌来认证用户，可以使用 `flask` 的 `itdangours` 生成令牌，`flask` 还内置了一个 `flask_httpauth` , 可以为我们提供2个装饰器，一个是提供认证的装饰器 `@auth.login_required`，一个是我们处理认证的装饰器 `@auth.verify_password` 。TOKEN 可以自定义要序列化的字段，先包含用户 ID 和登录类型 ac_type ,方便我们后续从 TOKEN 中验证用户，得到访问用户的行为。

### 四. 序列化

1. `Flask` 自带的 `json` 并不能序列化对象，也不能指定序列化的元素，所以我们需要自己重写 `JSONEncoder` ， 然后再重写一个 Flask 对象，继承原来的 Flask 对象，将内部的 `json_encoder` 替换成我们自己重写的 `JSONEncoder` 。
2. 序列化最好的元素是字典，但是类的 `__dict__ `方法没有将类变量(不是实例变量) 输出，我们需要使用 `dict() `方法，这个方法读取的数据是通过调用的对象的 `keys` 方法取到所有值，然后通过 `o[key]` 这样取值的，所以我们需要先在对象内实现 `keys` 方法，这个方法必须返回一个可迭代对象，我们可以自定义需要返回的元素。接下来还要构造 `o[key]` 来取得值，可以在类内编写 `__getiem__ `实现这个需求，然后通过 `getattr(self, item) `来返回值。

### 五. 权限管理

1. 为了防止超权，例如，获取信息接口只能获取用户自身的信息，而不能通过在 URL 后面拼接 UID 获取到其他用户的信息。最简单的方法是，不再通过在 URL 后面拼接 UID 的方式获取 UID，而是通过请求接口，然后我们从请求的 TOKEN 中提取 用户的 UID，这样有效防止超权。因为我们把用户信息保存在 flask 中的 g 变量中，是一个  FLASK 中的代理类型，保证了线程隔离，不会因为同时有 2 请求个访问，超出数据错乱的问题。
2. 前面的操作虽然防止了超权，但是我们肯定还是要提供一个可以访问所有用户信息的接口供内部人员使用，方便调试。这个需求我们可以通过在 TOKEN 中增加了另一个字段 is_admin，我们在每次给用户传递 TOKEN 时，都会查询用户表，如果是管理员，则 is_admin 是 1，其他是 0 ，那我们在验证 TOKEN 时，取出这个 is_admin的字段，然后将 用户 UID 和 is_admin一起保存在 g 变量中，然后管理员接口处判断一下 g 变量的 is_admin，如果不是 1，就放回一个权限不够的错误。
3. 上面第 2 步的操作虽然满足了需求，但是把权限的问题想的太简单了，因为管理员可能不止一种，可能有超级管理员，管理员，组长，普通用户，VIP 等等，如果我们按上面第 2 步中的写法，那每次增加一个类型的用户，就要在涉及权限的**所有**代码中修改，这样显然是很容易发生错误的。而且会让视图函数不够优雅，因为我们必须在每个可能涉及管理员的接口里面写上大量判断用户类型的代码，显示很臃肿。
4. 重构一下，我们把 TOKEN 中 is_admin 字段删除，再添加一个 scope 字段，这个字段是根据该用户在数据库中的管理员字段映射成对应的组用户，例如 AdminScope，UserScope, SuperAdminScope，等等，但是和第 2 步不同的地方在于，我们在验证 TOKEN 的时候，顺便从 request.endpoint 中读取到用户要访问的视图函数。这样，我们就能做一个权限配置类 scope，然后在类中添加允许访问的视图函数，然后每次用户在请求接口时，先判断他属于哪个 scope ，然后再验证一下，这个 scope 里面是否包含用户此时请求的视图函数，如果包含则返回，不包含在这一步直接放回异常，不用进入到视图函数中的逻辑中。
5. 我们再第4步中，传递的 scope 字段是一个字符串，通过 globa()\[string]() 可发射获得对应的类对象
